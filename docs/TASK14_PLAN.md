# DJGramm TASK14 — План налаштування frontend інструментів

## Огляд завдання

Модифікувати проект, додавши frontend інструменти (webpack) та інтегрувавши CSS фреймворк Tailwind CSS через webpack замість CDN.

**Основні цілі:**

1. **Налаштування webpack** — встановлення та конфігурація webpack для збірки JavaScript та CSS
2. **Інтеграція Tailwind CSS** — заміна CDN на локальну збірку через webpack
3. **AJAX функціональність** — покращення та оптимізація існуючих AJAX запитів
4. **Деплой** — оновлення процесу деплою для роботи з webpack
5. **Тестування** — написання тестів для нових функцій (pytest)

---

## Поточний стан проекту

### Що вже реалізовано:

- ✅ **Tailwind CSS** — використовується через CDN в `base.html`
- ✅ **JavaScript файли** — існують в `src/static/js/`:
  - `follow.js` — AJAX підписка/відписка
  - `feed.js` — функціональність стрічки
  - `post_detail.js` — деталі поста
  - `post_form.js` — форма створення поста
  - `main.js` — основний файл (поки порожній)
- ✅ **Pytest** — налаштований та працює, тести в `tests/`
- ✅ **Деплой** — налаштований через Docker (`docker-compose.prod.yml`)

### Що потрібно додати:

- ❌ **Webpack** — не налаштований (немає `package.json`, `webpack.config.js`)
- ❌ **Tailwind через webpack** — заміна CDN на локальну збірку
- ⚠️ **Оптимізація JavaScript** — об'єднання файлів, мініфікація
- ⚠️ **CSS обробка** — збірка Tailwind через PostCSS
- ⚠️ **Оновлення деплою** — додати збірку frontend в процес деплою

---

## Структура проекту

### Поточна структура (до TASK14)

```text
djgramm/
├── src/
│   ├── app/                    # Django додаток
│   │   ├── models.py
│   │   ├── views.py
│   │   ├── forms.py
│   │   ├── urls.py
│   │   ├── management/
│   │   └── templatetags/
│   ├── config/                 # Django налаштування
│   │   ├── settings.py
│   │   ├── urls.py
│   │   └── wsgi.py
│   ├── static/                # Статичні файли (не зібрані)
│   │   ├── js/
│   │   │   ├── main.js
│   │   │   ├── follow.js
│   │   │   ├── feed.js
│   │   │   ├── post_detail.js
│   │   │   └── post_form.js
│   │   └── css/
│   │       └── style.css
│   ├── templates/             # Django шаблони
│   │   ├── base.html          # (використовує Tailwind CDN)
│   │   └── app/
│   ├── media/                 # Завантажені файли
│   └── manage.py
├── tests/                     # Pytest тести
├── docker/                    # Docker конфігурації
├── docs/                      # Документація
├── scripts/                   # Утиліти
├── pyproject.toml            # Python залежності
└── docker-compose.yml
```

### Оновлена структура (після TASK14)

```text
djgramm/
├── frontend/                  # ✨ НОВА папка для frontend ресурсів
│   ├── src/                   # Вихідні файли для збірки
│   │   ├── js/                # JavaScript модулі
│   │   │   ├── index.js       # Entry point (імпортує всі модулі)
│   │   │   ├── main.js        # Переміщений з src/static/js/
│   │   │   ├── follow.js      # Переміщений з src/static/js/
│   │   │   ├── feed.js        # Переміщений з src/static/js/
│   │   │   ├── post_detail.js # Переміщений з src/static/js/
│   │   │   ├── post_form.js   # Переміщений з src/static/js/
│   │   │   └── utils/         # Утиліти (опціонально)
│   │   │       ├── csrf.js    # CSRF token утиліти
│   │   │       └── ajax.js    # Загальні AJAX функції
│   │   └── css/               # CSS файли
│   │       └── main.css       # ✨ НОВИЙ файл з Tailwind директивами
│   │                           # (@tailwind base/components/utilities)
│   └── dist/                  # Зібрані файли (ігнорується в git)
│       ├── main.js            # Зібраний JavaScript bundle
│       ├── main.css           # Зібраний CSS (Tailwind)
│       └── *.map              # Source maps (для debugging)
├── src/
│   ├── app/
│   ├── config/
│   ├── static/                # Статичні файли Django
│   │   ├── dist/              # ✨ НОВА папка для зібраних файлів
│   │   │   ├── main.js        # Скопійовано з frontend/dist/
│   │   │   └── main.css       # Скопійовано з frontend/dist/
│   │   ├── js/                # ⚠️ Старі файли (можна видалити після міграції)
│   │   └── css/
│   │       └── style.css      # Кастомні стилі (якщо є)
│   ├── templates/
│   │   ├── base.html          # ✨ ОНОВЛЕНО (використовує зібрані файли)
│   │   └── app/
│   ├── media/
│   └── manage.py
├── tests/
├── docker/
├── docs/
├── scripts/
├── package.json               # ✨ НОВИЙ файл (Node.js залежності)
├── package-lock.json          # ✨ НОВИЙ файл (закріплені версії)
├── webpack.config.js          # ✨ НОВИЙ файл (webpack конфігурація)
├── tailwind.config.js         # ✨ НОВИЙ файл (Tailwind конфігурація)
├── postcss.config.js          # ✨ НОВИЙ файл (PostCSS конфігурація)
├── .babelrc                   # ✨ НОВИЙ файл (опціонально, якщо використовується Babel)
├── pyproject.toml
├── docker-compose.yml
└── .gitignore                 # ✨ ОНОВЛЕНО (додано node_modules/, frontend/dist/)
```

### Ключові зміни в структурі

#### Нові файли та папки:

1. **`frontend/`** — нова папка для frontend розробки

   - `frontend/src/` — вихідні файли (JS, CSS)
   - `frontend/dist/` — зібрані файли (не комітиться в git)

2. **`package.json`** — Node.js залежності (webpack, tailwindcss, тощо)

3. **`webpack.config.js`** — конфігурація webpack для збірки

4. **`tailwind.config.js`** — конфігурація Tailwind CSS

5. **`postcss.config.js`** — конфігурація PostCSS (Tailwind + Autoprefixer)

6. **`src/static/dist/`** — папка для зібраних файлів, які використовує Django

#### Змінені файли:

1. **`src/templates/base.html`** — видалено Tailwind CDN, додано посилання на зібрані файли

2. **`.gitignore`** — додано:
   - `node_modules/`
   - `frontend/dist/`
   - `package-lock.json` (опціонально, залежно від політики проекту)
   - `*.map` (source maps, опціонально)

#### Переміщені файли:

- `src/static/js/*.js` → `frontend/src/js/*.js` (вихідні файли)
- Зібрані файли копіюються в `src/static/dist/` для використання Django

### Процес збірки

```text
frontend/src/          →  webpack  →  frontend/dist/  →  копіювання  →  src/static/dist/
(вихідні файли)        (збірка)    (зібрані файли)    (в Django)    (використовується Django)
```

### Оновлення .gitignore

**Додати до `.gitignore`:**

```gitignore
# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Webpack
frontend/dist/
*.map

# Package managers
package-lock.json  # (опціонально, якщо використовується yarn.lock)
```

---

## Фази реалізації

### Фаза 1: Налаштування Node.js та webpack

#### Крок 1.1: Встановлення Node.js залежностей

**Дії:**

1. Створити `package.json` в корені проекту
2. Встановити webpack та необхідні залежності:

   - `webpack` та `webpack-cli` (основні пакети)
   - `webpack-bundle-analyzer` (для аналізу розміру бандлу, опціонально)
   - `css-loader` та `style-loader` (для обробки CSS)
   - `postcss-loader` та `autoprefixer` (для PostCSS)
   - `tailwindcss` (локальна версія замість CDN)
   - `mini-css-extract-plugin` (для витягування CSS в окремий файл)
   - `terser-webpack-plugin` (для мініфікації JavaScript)
   - `copy-webpack-plugin` (для копіювання статичних файлів, якщо потрібно)

3. Додати dev-залежності:
   - `webpack-dev-server` (для розробки, опціонально)

**Результат:** `package.json` створений з усіма необхідними залежностями

#### Крок 1.2: Створення структури frontend файлів

**Дії:**

1. Створити папку `frontend/` в корені проекту (або `src/frontend/`)
2. Створити підпапки:
   - `frontend/src/` — вихідні JavaScript файли
   - `frontend/src/css/` — вихідні CSS файли (включаючи Tailwind)
   - `frontend/dist/` — зібрані файли (буде ігноруватися в git)

**Результат:** Структура папок для frontend файлів готова

#### Крок 1.3: Налаштування webpack.config.js

**Дії:**

1. Створити `webpack.config.js` в корені проекту
2. Налаштувати:

   - **Entry points** — вказати точки входу (основний JS файл, CSS файл)
   - **Output** — налаштувати вихідну папку (`src/static/dist/` або `src/staticfiles/`)
   - **Mode** — налаштувати режими `development` та `production`
   - **Loaders** — налаштувати обробку:
     - JavaScript файлів (Babel, якщо потрібно)
     - CSS файлів через `css-loader` та `style-loader`
     - PostCSS для Tailwind через `postcss-loader`
   - **Plugins** — додати:
     - `MiniCssExtractPlugin` для витягування CSS
     - `TerserPlugin` для мініфікації в production
   - **Optimization** — налаштувати оптимізацію для production

3. Додати окремий конфіг для development (опціонально)

**Результат:** Webpack налаштований для збірки JavaScript та CSS

---

### Фаза 2: Інтеграція Tailwind CSS через webpack

#### Крок 2.1: Встановлення та налаштування Tailwind CSS

**Дії:**

1. Ініціалізувати Tailwind CSS (створити `tailwind.config.js`)
2. Налаштувати `tailwind.config.js`:

   - Вказати шляхи до шаблонів Django (`content` paths)
   - Налаштувати кастомні кольори (якщо є в поточному конфігу)
   - Додати кастомні теми, якщо потрібно

3. Створити основний CSS файл (`frontend/src/css/main.css` або подібний):

   - Додати директиви Tailwind (`@tailwind base`, `@tailwind components`, `@tailwind utilities`)
   - Додати кастомні стилі, якщо є

4. Налаштувати PostCSS (`postcss.config.js`):
   - Додати `tailwindcss` плагін
   - Додати `autoprefixer` плагін

**Результат:** Tailwind CSS налаштований для роботи через webpack

#### Крок 2.2: Оновлення шаблонів Django

**Дії:**

1. Видалити CDN посилання на Tailwind з `base.html`
2. Додати посилання на зібраний CSS файл через `{% static %}` тег
3. Перевірити, що всі класи Tailwind працюють після зміни

**Результат:** Tailwind CSS завантажується з локальної збірки замість CDN

#### Крок 2.3: Налаштування webpack для Tailwind

**Дії:**

1. Оновити `webpack.config.js`:

   - Додати обробку CSS файлів через PostCSS
   - Налаштувати `postcss-loader` з Tailwind
   - Переконатися, що Tailwind класи з шаблонів скануються

2. Протестувати збірку:
   - Запустити `npm run build` (або `yarn build`)
   - Перевірити, що CSS файл створений
   - Перевірити, що всі стилі працюють

**Результат:** Tailwind збирається через webpack

---

### Фаза 3: Реорганізація JavaScript файлів

#### Крок 3.1: Об'єднання JavaScript модулів

**Дії:**

1. Реорганізувати існуючі JS файли:

   - Перемістити файли з `src/static/js/` в `frontend/src/`
   - Розбити на модулі (ES6 modules), якщо потрібно
   - Створити основний entry point (`frontend/src/index.js`)

2. Налаштувати імпорти:

   - Імпортувати всі модулі в головний файл
   - Налаштувати залежності між модулями

3. Додати утиліти (якщо потрібно):
   - Функції для роботи з CSRF токенами
   - Загальні AJAX утиліти
   - Обробка помилок

**Результат:** JavaScript файли реорганізовані та готові до збірки

#### Крок 3.2: Створення спільних утиліт та оптимізація коду

**Дії:**

1. Створити модуль утиліт (`frontend/src/js/utils/`):

   - `csrf.js` — централізована функція для отримання CSRF токена (видаляє дублювання коду)
   - `ajax.js` — загальний модуль для AJAX запитів з:
     - Обробкою помилок
     - Індикаторами завантаження
     - Retry логікою (опціонально)
     - Timeout обробкою
   - `errors.js` — централізована обробка помилок та показ повідомлень користувачу
   - `dom.js` — утиліти для роботи з DOM (опціонально)

2. Рефакторинг існуючих файлів:

   - Замінити дубльовані функції `getCsrfToken()` на імпорт з `utils/csrf.js`
   - Використати загальний AJAX модуль замість окремих `fetch()` викликів
   - Винести спільну логіку в утиліти

3. Оптимізація коду:
   - Видалити дублювання коду між файлами
   - Використати ES6 modules для кращого tree shaking
   - Мінімізувати глобальні змінні

**Результат:** Код оптимізований, дублювання видалено, спільні утиліти створені

#### Крок 3.3: Покращення AJAX функціональності

**Дії:**

1. Оптимізувати існуючі AJAX запити:

   - Використати загальний AJAX модуль з утиліт
   - Додати індикатори завантаження для всіх AJAX операцій
   - Покращити обробку відповідей (уніфікований формат)
   - Додати debounce/throttle для часті запити (якщо потрібно)

2. Додати нові AJAX функції (якщо потрібно):

   - Infinite scroll для стрічки (опціонально)
   - Real-time оновлення (опціонально)
   - Покращена обробка форм з валідацією

3. Додати валідацію на клієнті:
   - Валідація форм перед відправкою
   - Перевірка розміру файлів на клієнті
   - Валідація типів файлів

**Результат:** AJAX функціональність покращена та оптимізована

#### Крок 3.4: Налаштування webpack для JavaScript з оптимізаціями

**Дії:**

1. Оновити `webpack.config.js`:

   - Налаштувати entry point для JavaScript
   - Додати обробку ES6+ синтаксису (Babel, якщо потрібно підтримувати старі браузери)
   - Налаштувати мініфікацію для production з `TerserPlugin`
   - **Увімкнути Tree Shaking** — автоматично видаляє невикористаний код
   - Налаштувати code splitting (якщо потрібно):
     - Розділити vendor код (якщо додаються бібліотеки)
     - Dynamic imports для lazy loading (опціонально)
   - Налаштувати source maps:
     - Development: `eval-source-map` (швидко)
     - Production: `source-map` або `hidden-source-map` (опціонально)

2. Оптимізація bundle:

   - Використати `webpack-bundle-analyzer` для аналізу розміру
   - Перевірити, що tree shaking працює (невикористаний код видаляється)
   - Оптимізувати імпорти (використовувати named imports замість default, якщо можливо)

3. Протестувати збірку:
   - Перевірити, що всі модулі збираються
   - Перевірити розмір bundle (має бути оптимальним)
   - Перевірити, що мініфікація працює
   - Перевірити, що source maps працюють (для debugging)

**Результат:** JavaScript збирається через webpack з оптимізаціями

---

### Фаза 4: Оновлення Django settings для статичних файлів

#### Крок 4.1: Налаштування STATICFILES_DIRS та оптимізація

**Дії:**

1. Оновити `src/config/settings.py`:

   - Додати шлях до зібраних файлів в `STATICFILES_DIRS` (якщо потрібно)
   - Переконатися, що `STATIC_ROOT` вказує на правильну папку
   - Налаштувати кешування статичних файлів:
     - Додати `STATICFILES_STORAGE` для production (якщо потрібно)
     - Налаштувати cache headers для статичних файлів

2. Налаштувати обробку статичних файлів:

   - Переконатися, що WhiteNoise налаштований правильно
   - Налаштувати WhiteNoise для кешування:
     - `WHITENOISE_MAX_AGE` — час кешування (наприклад, 31536000 для 1 року)
     - `WHITENOISE_USE_FINDERS` — для development
   - Перевірити, що зібрані файли знаходяться в правильній папці

3. Оптимізація завантаження:
   - Додати hash до імен файлів (webpack автоматично додає content hash)
   - Налаштувати long-term caching для статичних файлів

**Результат:** Django знає, де знаходяться зібрані статичні файли, кешування налаштоване

#### Крок 4.2: Оновлення шаблонів

**Дії:**

1. Оновити `base.html`:

   - Замінити посилання на окремі JS файли на зібраний bundle
   - Замінити CDN Tailwind на локальний CSS файл

2. Перевірити всі шаблони:
   - Переконатися, що всі статичні файли завантажуються правильно
   - Перевірити, що немає конфліктів з існуючими скриптами

**Результат:** Шаблони оновлені для використання зібраних файлів

---

### Фаза 5: Налаштування скриптів збірки

#### Крок 5.1: Додавання npm scripts з оптимізаціями

**Дії:**

1. Оновити `package.json`:

   - Додати скрипт `build` для production збірки
   - Додати скрипт `build:analyze` для аналізу розміру bundle (з bundle-analyzer)
   - Додати скрипт `dev` для development збірки (з watch mode)
   - Додати скрипт `watch` для автоматичної перезбірки під час розробки
   - Додати скрипт `clean` для очищення папок dist (опціонально)

2. Налаштувати змінні оточення:

   - Використовувати `NODE_ENV` для визначення режиму
   - Налаштувати різні конфіги для development та production
   - Додати автоматичне копіювання файлів після збірки (через webpack plugin або окремий скрипт)

3. Оптимізація процесу збірки:
   - Використати `webpack` в watch режимі для development
   - Додати перевірку помилок перед збіркою (lint, якщо є)
   - Налаштувати паралельну збірку (якщо потрібно)

**Результат:** Скрипти для збірки налаштовані з оптимізаціями

#### Крок 5.2: Інтеграція з Django командами (опціонально)

**Дії:**

1. Створити Django management command:

   - Команда для запуску webpack збірки
   - Команда для комбінованого запуску (міграції + збірка)

2. Додати в процес розробки:
   - Автоматичний запуск збірки перед `runserver` (опціонально)
   - Інтеграція з Docker (опціонально)

**Результат:** Збірка інтегрована в Django workflow

---

### Фаза 6: Оновлення процесу деплою

#### Крок 6.1: Оновлення Dockerfile

**Дії:**

1. Оновити `docker/Dockerfile` та `docker/Dockerfile.prod`:

   - Додати встановлення Node.js
   - Додати встановлення npm залежностей (`npm install`)
   - Додати збірку frontend (`npm run build`)
   - Оптимізувати порядок операцій для кешування

2. Налаштувати multi-stage build (якщо потрібно):
   - Stage 1: Встановлення Node.js та збірка frontend
   - Stage 2: Python та Django setup
   - Stage 3: Фінальний образ

**Результат:** Dockerfile оновлений для збірки frontend

#### Крок 6.2: Оновлення docker-compose

**Дії:**

1. Оновити `docker-compose.yml` та `docker-compose.prod.yml`:

   - Переконатися, що volumes правильно налаштовані
   - Додати змінні оточення для Node.js (якщо потрібно)

2. Оновити entrypoint скрипти:
   - Додати збірку frontend перед запуском Django
   - Переконатися, що `collectstatic` виконується після збірки

**Результат:** Docker Compose оновлений для роботи з webpack

#### Крок 6.3: Оновлення CI/CD (якщо є)

**Дії:**

1. Оновити GitLab CI / GitHub Actions:

   - Додати встановлення Node.js
   - Додати збірку frontend перед тестами
   - Переконатися, що зібрані файли включені в артефакти

2. Додати перевірки:
   - Перевірка розміру bundle (опціонально)
   - Перевірка мініфікації (опціонально)

**Результат:** CI/CD оновлений для роботи з webpack

---

### Фаза 7: Тестування

#### Крок 7.1: Тести для frontend функціональності

**Дії:**

1. Написати тести для JavaScript (опціонально):

   - Використовувати Jest або інший JS test runner
   - Тестувати AJAX функції
   - Тестувати утиліти

2. Інтеграційні тести:
   - Тестувати, що зібрані файли завантажуються
   - Тестувати, що всі функції працюють після збірки

**Результат:** Тести для frontend написані (якщо вирішено додати)

#### Крок 7.2: Оновлення існуючих pytest тестів

**Дії:**

1. Перевірити існуючі тести:

   - Переконатися, що тести проходять після змін
   - Оновити тести, якщо потрібно (наприклад, перевірка статичних файлів)

2. Додати нові тести (якщо потрібно):
   - Тести для перевірки наявності зібраних файлів
   - Тести для перевірки правильності завантаження статичних файлів

**Результат:** Pytest тести оновлені та проходять

#### Крок 7.3: Ручне тестування

**Дії:**

1. Протестувати в development режимі:

   - Перевірити, що всі сторінки завантажуються
   - Перевірити, що всі JavaScript функції працюють
   - Перевірити, що всі стилі застосовуються правильно

2. Протестувати в production режимі:
   - Перевірити мініфікацію
   - Перевірити оптимізацію
   - Перевірити розмір файлів

**Результат:** Всі функції протестовані вручну

---

## Оптимізації та покращення

### Оптимізація коду та структури

#### Видалення дублювання коду

**Проблема:** Функція `getCsrfToken()` дублюється в кожному JS файлі.

**Рішення:**

- Створити модуль `frontend/src/js/utils/csrf.js` з централізованою функцією
- Імпортувати в усі файли, що потребують CSRF токен
- Видалити дубльовані функції

**Переваги:**

- Менше коду для підтримки
- Легше вносити зміни (одне місце)
- Tree shaking видалить невикористаний код

#### Централізація AJAX запитів

**Проблема:** Кожен файл має свою реалізацію `fetch()` з обробкою помилок.

**Рішення:**

- Створити модуль `frontend/src/js/utils/ajax.js` з функціями:
  - `ajaxGet(url, options)` — GET запити
  - `ajaxPost(url, data, options)` — POST запити
  - Загальна обробка помилок
  - Індикатори завантаження
  - Retry логіка (опціонально)

**Переваги:**

- Уніфікована обробка помилок
- Легше додавати нові функції (logging, analytics)
- Менше коду в кожному модулі

#### Оптимізація розміру bundle

**Рекомендації:**

1. **Tree Shaking:**

   - Використовувати ES6 modules замість CommonJS
   - Використовувати named imports замість default imports, де можливо
   - Переконатися, що webpack налаштований для tree shaking

2. **Аналіз bundle:**

   - Використовувати `webpack-bundle-analyzer` для виявлення великих залежностей
   - Перевіряти розмір bundle після кожної зміни
   - Цільовий розмір: JavaScript < 200KB (gzipped), CSS < 50KB (gzipped)

3. **Code Splitting:**

   - Розділити vendor код (якщо додаються бібліотеки)
   - Використовувати dynamic imports для lazy loading (якщо потрібно)

4. **Мініфікація:**
   - Увімкнути TerserPlugin для production
   - Налаштувати оптимізацію (compress, mangle)

### Додаткові покращення (опціонально)

#### Code Splitting

**Інструкції:**

1. Налаштувати code splitting в webpack:

   - Розділити код на chunks
   - Використовувати dynamic imports для lazy loading
   - Виділити vendor код в окремий chunk

2. Переваги:
   - Менший розмір початкового bundle
   - Швидше завантаження сторінок
   - Краще кешування (vendor код змінюється рідше)

#### Source Maps

**Інструкції:**

1. Налаштувати source maps в webpack:

   - Для development: `eval-source-map` (швидко) або `source-map` (детально)
   - Для production: `hidden-source-map` (для error tracking) або без них

2. Переваги:
   - Легше debugging в браузері
   - Краще відстеження помилок в production (з Sentry або подібними сервісами)

#### Hot Module Replacement (HMR)

**Інструкції:**

1. Налаштувати HMR для development:

   - Використовувати `webpack-dev-server` (складніше для Django)
   - Або використовувати watch mode з автоматичною перезбіркою

2. Переваги:
   - Швидша розробка
   - Збереження стану під час змін

**Примітка:** HMR з Django вимагає додаткового налаштування, тому watch mode може бути простішим рішенням.

#### Кешування статичних файлів

**Інструкції:**

1. Налаштувати кешування:

   - Webpack автоматично додає content hash до імен файлів
   - Налаштувати WhiteNoise для long-term caching
   - Додати cache headers в Nginx (якщо використовується)

2. Переваги:
   - Швидше завантаження для повторних відвідувань
   - Менше навантаження на сервер

#### Оптимізація Tailwind CSS

**Інструкції:**

1. Налаштувати PurgeCSS (вже включений в Tailwind):

   - Переконатися, що `content` paths в `tailwind.config.js` правильні
   - Використовувати JIT mode (вже в Tailwind 3+)
   - Перевірити розмір зібраного CSS

2. Переваги:
   - Менший розмір CSS файлу
   - Тільки використані класи включаються в bundle

---

## Checklist перед завершенням

### Налаштування

- [ ] `package.json` створений з усіма залежностями
- [ ] `webpack.config.js` налаштований для development та production
- [ ] `tailwind.config.js` налаштований з правильними paths
- [ ] `postcss.config.js` налаштований з Tailwind та Autoprefixer
- [ ] Структура frontend папок створена

### Інтеграція

- [ ] Tailwind CDN видалено з `base.html`
- [ ] Зібраний CSS файл підключено в шаблонах
- [ ] Зібраний JavaScript bundle підключено в шаблонах
- [ ] Дубльований код видалено (CSRF функції винесені в утиліти)
- [ ] AJAX запити використовують спільний модуль
- [ ] Всі існуючі функції працюють після змін

### Збірка

- [ ] `npm run build` працює без помилок
- [ ] `npm run dev` працює для розробки
- [ ] `npm run build:analyze` показує аналіз bundle
- [ ] Мініфікація працює в production режимі
- [ ] Tree shaking працює (невикористаний код видаляється)
- [ ] Source maps працюють (якщо налаштовані)
- [ ] Розмір bundle оптимальний (JS < 200KB, CSS < 50KB gzipped)

### Деплой

- [ ] Dockerfile оновлений для збірки frontend
- [ ] docker-compose оновлений
- [ ] CI/CD оновлений (якщо є)
- [ ] Деплой на сервер працює з новими змінами

### Тестування

- [ ] Всі існуючі pytest тести проходять
- [ ] Ручне тестування пройдено
- [ ] Перевірено в development та production режимах
- [ ] Перевірено розмір bundle (не надто великий)

### Документація

- [ ] README оновлений з інструкціями по збірці
- [ ] Додано інструкції по встановленню Node.js залежностей
- [ ] Додано інструкції по запуску збірки

---

## Ресурси

- [Webpack Documentation](https://webpack.js.org/concepts/)
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [PostCSS Documentation](https://postcss.org/)
- [Django Static Files](https://docs.djangoproject.com/en/stable/howto/static-files/)
- [Webpack + Django Integration](https://webpack.js.org/guides/production/)

---

## Підсумок

**TASK14 додає до проекту:**

- Webpack для збірки frontend ресурсів
- Tailwind CSS інтегрований через webpack (замість CDN)
- Оптимізовані та мініфіковані JavaScript та CSS файли
- Централізовані утиліти (CSRF, AJAX) — видалено дублювання коду
- Tree shaking для автоматичного видалення невикористаного коду
- Покращений процес деплою з автоматичною збіркою frontend
- Кешування статичних файлів для кращої продуктивності
- Готовність до масштабування frontend функціональності

**Ключові оптимізації:**

- ✅ Видалено дублювання коду (CSRF функції)
- ✅ Централізована обробка AJAX запитів
- ✅ Tree shaking для мінімізації bundle
- ✅ Оптимізація Tailwind CSS (тільки використані класи)
- ✅ Кешування статичних файлів

**Готово до початку реалізації!**
